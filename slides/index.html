<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>WebAssembly</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">
		<link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- style inline <code> -->
        <style>
            .reveal :not(pre) > code {
                color: #e3ceab;
                font-size: 75%;
            }
            .reveal .yay {
                color: #1b91ff;
                font-size: 125%;
            }
            .reveal .blue {
                color: #1b91ff;
            }
            .reveal .snowmen-list {
                list-style: none;
                margin-left: 0;
                padding-left: 1em;
                text-indent: -1em;
            }
            .reveal .snowmen-list li:before {
                content: "☃";
                padding-right: .5em;
            }

            .reveal .watermark {
                position: absolute;
                right: 0;
                bottom: 0;
                z-index: 10;
                font-size: 5vh;
                padding: .5rem;
                background: white;
                border-radius: .5rem 0 0 0;
                color: black;
            }

        </style>
	</head>
	<body>
        <div class="reveal">
            <div class="watermark">@callahad</div>
            <div class="slides">


            <section>
                <p><em>Slides derived from a deck by <a href="http://dancallahan.info">Dan Callahan</a> who 
			derived his from <br> <a href="http://lukewagner.name">Luke Wagner</a> / <a href="https://twitter.com/luke_wagner">@luke_wagner</a></em></p>
                <p><small>(Mozillian, Co-chair WebAssembly W3C Community Group)</small></p>
            </section>




            <section>
                <h2>What is WebAssembly?</h2>
                <p>
                    A <em>new standard</em> being developed in a W3C Community
                    Group with Apple, Google, Microsoft and Mozilla which
                    defines:
                </p>
                <ol>
                    <li>
                        a compact, 
                        portable <em class="fragment highlight-current-blue">binary format</em> which is
                        fast to load and runs
                        safely at 
                        predictably near-native speed
                    </li>
                    <li>
                        a 1:1 <em class="fragment highlight-current-blue">text format</em>
                        rendered by developer tools when 
                        viewing source
                    </li>
                </ol>
            </section>

            <section>
                <p>So what is WebAssembly <em>really</em>?</p>
                <a href="https://video.yahoo.com/shimmer-floor-wax-000000185.html"><img src="dessert-or-wax.jpg" /></a>
                <p>It's a couple things, depending on what you're doing:</p>
            </section>

            <section>
                <h2>1. Compiler Target for the Web</h2>
                <p>Not a programming language</p>
                <p>Compile <em>from</em> programming languages</p>
            </section>


            <section>
                <h2>2. JavaScript Feature</h2>
                <p>Ability to efficiently load large code +</p>
                <p>predictable near-native performance =</p>
                <p>Powerful library-building tool</p>
            </section>


            <section>
                <h2>3. Virtual CPU</h2>
                <p>As close to physical machine instructions as safety/portability allow</p>
                <table>
                    <tr>
                        <th>WebAssembly</th>
                        <th></th>
                        <th>x86</th>
                        <th>ARM</th>
                    </tr>
                    <tr>
                        <td><code>i32.add</code></td>
                        <td>↦</td>
                        <td><code>addl</code></td>
                        <td><code>ADD</code></td>
                    </tr>
                        <td><code>call</code></td>
                        <td>↦</td>
                        <td><code>call</code></td>
                        <td><code>BL</code></td>
                    </tr>
                    <tr>
                        <td><code>i32.load</code></td>
                        <td>↦</td>
                        <td>check + <code>mov</code></td>
                        <td>check + <code>LDR</code></td>
                    </tr>
                </table>
            </section>


            <section>
                <h2>4. Evolution of asm.js</h2>
                <small>
                    (tl;dr - <em>asm.js</em> is an extraordinarily optimizable,
                     low-level <em>subset of JavaScript</em> that can be compiled from
                     languages like C/C++ and shipped on the Web <em>today</em>)
                </small>
                <p>Can think of WebAssembly as a binary encoding of asm.js with tweaks to make it a better compiler target</p>
                <table>
                    <tr>
                        <th>asm.js</th>
                        <th></th>
                        <th>WebAssembly</th>
                    </tr>
                    <tr>
                        <td><code>(x+y)|0</code></td>
                        <td>↦</td>
                        <td><code>i32.add</code></td>
                    </tr>
                    <tr>
                        <td><code>f()|0</code></td>
                        <td>↦</td>
                        <td><code>call</code></td>
                    </tr>
                    <tr>
                        <td><code>HEAP32[i&gt;&gt;2]|0</code></td>
                        <td>↝</td>
                        <td><code>i32.load</code></td>
                    </tr>
                </table>
            </section>


            <section>
                <h2>Why WebAssembly?</h2>
                <p>Why do we <em>need</em> this new target / feature / CPU / asm.js++?</p>
            </section>


            <section>
                <h2>Short History of asm.js</h2>
                <table>
                    <tr>
                        <td>2009 - 2012</td>
                        <td>
                            Mozilla Research experiments:<br>
                            <em>Emscripten</em>: C/C++ to JS compiler/toolchain<br>
                            <em>asm.js</em>: optimize Emscripten-style output
                        </td>
                    </tr>
                    <tr>
                        <td>2013 - 2014</td>
                        <td>
                            Published <em>asm.js</em> subset, shipped optimizations
                            in Firefox, demonstrated on large game engines
                        </td>
                    </tr>
                    <tr>
                        <td>2015 - 2016</td>
                        <td>
                            <p>
                                asm.js optimizations shipping or under development in
                                <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/asmjs">Edge</a>,
                                <a href="https://www.chromestatus.com/features#asm.js">Chrome</a> and 
                                <a href="https://webkit.org/status/#feature-asm.js">Safari</a>
                            </p>
                            <p>Adobe, AutoDesk, Epic, Facebook, Mega, Unity, and more shipping with Emscripten/asm.js</p>
                        </td>
                    </td>
                </table>
            </section>


            <section>
                <h2>Why WebAssembly?</h2>
                <p>asm.js use today demonstrates real demand and excitement</p>
                <p>asm.js use cases:</p>
                <ul>
                    <li>avoid plugins (deprecation, friction, security)</li>
                    <li>bring existing applications to the Web (too big to rewrite)</li>
                    <li>port high-performance C/C++ libraries for use by JS</li>
                    <li>predictable near-native performance (compared to JS)</li>
                </ul>
            </section>


            <section>
                <h2>But Why WebAssembly?</h2>
                <p>Because we need to go farther than we can with asm.js.</p>
                <p>Based on feedback from developers, we need to:</p>
                <ul>
                    <li>further reduce load time (especially on mobile)</li>
                    <li>reduce over-the-wire size (with and without compression)</li>
                    <li>reduce runtime memory consumption for code</li>
                    <li>new features that don't fit neatly into asm.js</li>
                    <li>keep pushing closer to native code performance</li>
                </ul>
                <p>
                    (Also <em>shared memory</em>, but 
                    <a href="http://tc39.github.io/ecmascript_sharedmem/shmem.html">that's coming in JS</a> too.)
                </p>
            </section>


            <section>
                <p><img src="construction.gif" /></p>
                <p>WebAssembly is a Work In Progress</p>
                <p>Recently reached Firefox/Chrome/Edge interop <a href="http://webassembly.github.io/demo">milestone</a>!</p>
                <p>More iteration before stable spec and ship in browsers</p>
                <p>Want to ship this year <small>(with usual standardization caveats)</small></p>
            </section>
            <section>
                <p><img src="construction.gif" /></p>
                <p>WebAssembly is being specified and shipped <em>iteratively</em>.</p>
                <p>The initial release focuses on a Minimum Viable Product: compiling C/C++, better asm.js.</p>
                <p>(This means we can use asm.js to write <a href="https://github.com/WebAssembly/design/blob/master/FAQ.md#can-the-polyfill-really-be-efficient">polyfills</a>!)</p>
                <p>But there is a <em>lot</em> more we want to do next!</p>
            </section>
            <section>
                <h3>Let's take a little tour!</h3>
            </section>


            <section>
                <p>Start with some C code:</p>
                <pre><code class="c" data-trim>
// demo.c
DLL_EXPORT
int add(int lhs, int rhs) {
    return lhs + rhs;
}
                </code></pre>
                where functions we want to call from JS are <em>exported</em>:
                <pre><code class="c" data-trim>
// However DLL/DSO exports are defined in your compiler
#define DLL_EXPORT __attribute__ ((visibility ("default")))
                </code></pre>
                <p>then compile to <code>wasm</code>:</p>
                <pre><code class="bash" data-trim>
☃ clang -mwasm demo.c -o demo.wasm
                </code></pre>
            </section>


            <section>
                <p>Render the binary as text:</p>
                <pre><code class="bash" data-trim>
☃ wasm2text demo.wasm | less
                </code></pre>
                <pre><code class="lisp" data-trim>
(module
    (func $add (param $lhs i32) (param $rhs i32) (result i32)
        (i32.add (get_local $lhs) (get_local $rhs))
    )
    (export "add" $add)
)
                </code></pre>
            </section>


            <section>
                <p>Today, we load the <code>wasm</code> via JS API:</p>
                <pre><code class="js" data-trim>
fetch('demo.wasm').then(response =>
    response.arrayBuffer()
).then(buffer => {
    let codeBytes = new Uint8Array(buffer);
    let instance = Wasm.instantiateModule(codeBytes);
    alert("1 + 2 = " + instance.exports.add(1, 2));
});
                </code></pre>
            </section>




            <section>
                <p>☃ In the future, (present???) with ES6 Module integration:</p>
                <pre><code class="html" data-trim>
<script type='module'>
    import add from 'demo.wasm';
    alert("1 + 2 = " + add(1, 2));
</script>
                </code></pre>
            </section>

            <section>
                <p>WebAssembly can call JavaScript too!</p>
                <pre><code class="c" data-trim>
// main.c
extern DLL_IMPORT void printInt(int);
int main() {
    printInt(42);
}
                </code></pre>
                where JS functions we want to call from <code>wasm</code> are <em>imported</em>:
                <pre><code class="c" data-trim>
// However DLL/DSO imports are defined in your compiler
#define DLL_IMPORT __attribute__ ((visibility ("default")))
                </code></pre>
                <p>then compile to <code>wasm</code>:</p>
                <pre><code class="bash" data-trim>
☃ clang -mwasm main.c -o main.wasm
                </code></pre>
            </section>


            <section>
                <p>Rendering the binary as text:</p>
                <pre><code class="bash" data-trim>
☃ wasm2text main.wasm | less
                </code></pre>
                <pre><code class="lisp" data-trim>
(module
    (import "imports" "printInt" (param i32))
    (func $main (call_import 0 (i32.const 42)))
    (start $main)
)
                </code></pre>
            </section>


            <section>
                <p>Now write the ES6 module which is called by <code>wasm</code>:</p>
                <pre><code class="js" data-trim>
// imports.js
export var printInt = i => console.log(i);
                </code></pre>
                <p>☃ and load the <code>wasm</code> from a <code>&lt;script type='module'&gt;</code> tag:</p>
                <pre><code class="html" data-trim>
<script type='module' src='main.wasm'></script>
                </code></pre>
                <p>Imports can also just be functions passed to the JS API:</p>
                <pre><code class="js" data-trim>
var codeBytes = ...;
var imports = {printInt:i => console.log(i)};
Wasm.instantiateModule(codeBytes, {imports});
                </code></pre>
            </section>


            <section>
                <p>Now let's look at an actual computation:</p>
                <pre><code class="html" data-trim data-noescape>
// accum.c
DLL_EXPORT
int accum(<span class="fragment highlight-current-blue" data-fragment-index="2">int* i, int* end</span>) {
    <span class="fragment highlight-current-blue" data-fragment-index="1">int sum = 0;</span>
    <span class="fragment highlight-current-blue" data-fragment-index="3">for (;</span> <span class="fragment highlight-current-blue" data-fragment-index="4">i != end</span>; <span class="fragment highlight-current-blue" data-fragment-index="5">i++</span><span class="fragment highlight-current-blue" data-fragment-index="3">)</span>
        <span class="fragment highlight-current-blue" data-fragment-index="1">sum +=</span> <span class="fragment highlight-current-blue" data-fragment-index="2">*i</span>;
    <span class="fragment highlight-current-blue" data-fragment-index="1">return sum;</span>
}
                </code></pre>
                <div class="fragment" data-fragment-index="0">
                <p>This compiles to the function:</p>
                <pre><code class="html" data-trim data-noescape>
(func $accum <span class="fragment highlight-current-blue" data-fragment-index="2">(param $i i32) (param $end i32)</span> (result i32)
    <span class="fragment highlight-current-blue" data-fragment-index="1">(local $sum i32)</span>
    <span class="fragment highlight-current-blue" data-fragment-index="3">(loop</span> <span class="fragment highlight-current-blue" data-fragment-index="4">$break</span> <span class="fragment highlight-current-blue" data-fragment-index="3">$top</span>
        <span class="fragment highlight-current-blue" data-fragment-index="4">(br_if $break (i32.eq (get_local $i) (get_local $end)))</span>
        <span class="fragment highlight-current-blue" data-fragment-index="1">(set_local $sum (i32.add (get_local $sum)</span>
                                 <span class="fragment highlight-current-blue" data-fragment-index="2">(i32.load (get_local $i))</span>))
        <span class="fragment highlight-current-blue" data-fragment-index="5">(set_local $i (i32.add (get_local $i) (i32.const 4)))</span>
        <span class="fragment highlight-current-blue" data-fragment-index="3">(br $top)
    )</span>
    <span class="fragment highlight-current-blue" data-fragment-index="1">(get_local $sum)</span>
) <span class="fragment fade-in yay" data-fragment-index="6">\o/</span>
                </code></pre>
                </div>
            </section>


            <section>
                <p>The containg module declares and exports <code>memory</code></p>
                <pre><code class="lisp" data-trim>
(module
    (memory 1)  ;; declare one page of memory = 64KiB
    (export "memory" memory)
    (func $accum ...)
    (export "accum" $accum)
)
                </code></pre>
                <p>Which we can then access from JS:</p>
                <pre><code class="js" data-trim>
var codeBytes = ...;
var instance = Wasm.instantiateModule(codeBytes);

// Create an array of integers 1..10
var i32 = new Int32Array(instance.exports.memory);
for (var i = 0; i < 10; i++)
    i32[i] = i + 1;

console.log(instance.exports.accum(0, 10 * 4));  // "55"
                </code></pre>
            </section>

            <section>
                <h2>End of the Tour</h2>
                <p>What we've seen so far:</p>
                <ul>
                    <li>Calling to and from JavaScript</li>
                    <li>ES6 module integration ☃</li>
                    <li>Computation</li>
                </ul>
                <p class="fragment">But what about APIs?</p>
            </section>


            <section>
                <p>On a traditional virtual platform:</p>
                <img src="traditional-vm-platform.png" />
                <p>&nbsp;</p>
            </section>


            <section>
                <p>On a modern Web browser:</p>
                <img src="web-platform-1.png" />
                <p>The Web is starting to resemble a traditional virtual platform</p>
            </section>
            <section>
                <p>... with some special "Webby" properties like:<p>
                <img src="web-platform-2.png" />
                <p>... open standards, multiple implementations, etc<p>
            </section>
            <section>
                <p class="fragment">Q: So what are WebAssembly APIs? Answer 1: Web APIs!</p>
                <img src="web-platform-wasm.png" />
                <p class="fragment blue">This is a key difference from plugin architectures</p>
            </section>


            <section>
                <h2>Web API integration</h2>
                <p>Today, WebAssembly only gets to Web APIs by <br> "thunking" through JavaScript</p>
                <p>☃ In the future, support calling Web APIs <em>directly</em></p>
            </section>

            <section>
                <p class="fragment">Q: So what are WebAssembly APIs? Answer 2: WASI!</p>
                <p>WASI is a more traditional desktop/server API: files, streams, network connections, clocks, and random numbers</p>
            </section>


	</body>
</html>
